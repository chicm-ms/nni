# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.


import logging
import queue
import re
import torch

_logger = logging.getLogger(__name__)


class GNode:
    """
    It is used to represent a node in model graph, in this graph a module is a node,
    a function out of module (in ```forward``` function) could also be a node.
    """
    def __init__(self, node_name, node_type, op_type, inputs, outputs, nodes):
        """
        Parameters
        ----------
        node_name : str
            It is module name if the node is a module, it is ```scope_name.node_kind.seq``` if it is a func
        node_type : str
            It only has two options: `module` or `func`
        op_type : str
            The operation type of the module or func
        inputs : list of str
            All the inputs of this node, each element is debugName of one input
        outputs : list of str
            All the outputs of this node, each element is debugName of one output
        nodes : list of node
            All the trace graph nodes included in this module or func
        """
        self.name = node_name
        self.type = node_type
        self.op_type = op_type
        self.inputs = inputs
        self.outputs = outputs
        self.nodes = nodes
        # store supplementary information for different op types
        # for example, for ```view``` it stores the shape of its input and output
        self.auxiliary = None

    def __repr__(self):
        return 'name: {}, type: {}, op_type: {}: auxiliary: {}, inputs: {}, outputs: {}'.format(
            self.name, self.type, self.op_type, self.auxiliary, self.inputs, self.outputs
        )


class TorchGraph:
    """
    This class is to extract pytorch model topology graph by tracing
    """

    def __init__(self, model, dummy_input):
        """
        Parameters
        ----------
        model : pytorch model
            The model user wants to speed up
        dummy_input : pytorch tensor
            The dummy input for ```jit.trace```, users should put it on right device before pass in
        """
        assert torch.__version__ >= '1.3.1'
        self.bound_model = model
        self.g_nodes = list()
        self.global_count = 0

        self._trace(model, dummy_input)
        self.name_to_gnode, self.input_to_gnode, self.output_to_gnode = self._build_graph()

    def _trace(self, model, dummy_input):
        with torch.onnx.set_training(model, False):
            self.trace = torch.jit.trace(model, dummy_input)
            torch._C._jit_pass_inline(self.trace.graph)

    def _build_index_for_gnodes(self, g_nodes):
        """
        Build indexes for quick search

        Parameters
        ----------
        g_nodes : list of GNode
            All the g_node in processed model graph

        Returns
        -------
        dict
            use name to index g_nodes, key: node name, value: g_node
        dict
            use input (its name) to index g_nodes,
            key: input, value: list of g_nodes that take this input
        dict
            use output (its name) to index g_nodes,
            key: output, value: g_node that generates this output
        """
        name_to_gnode = dict()
        input_to_gnode = dict()
        output_to_gnode = dict()
        for node in g_nodes:
            name_to_gnode[node.name] = node
            for _input in node.inputs:
                if _input in input_to_gnode:
                    input_to_gnode[_input].append(node)
                else:
                    input_to_gnode[_input] = [node]
            for output in node.outputs:
                assert not output in output_to_gnode, \
                    "One output cannot be generated by multiple nodes"
                output_to_gnode[output] = node
        return name_to_gnode, input_to_gnode, output_to_gnode

    def _expand_non_prim_node(self, node, nodes, input_to_node, output_to_node):
        """
        For trace graph nodes, some nodes are not in modules, these nodes are usually generated by
        the functions directly called in module ```forward```. For such nodes, some of them are
        trivial op which are label by ```prim::```, some of them are not such ops which is call
        non-prim ops. This function is to merge neighbor prim ops to a non-prim op, to construct
        a GNode.

        Parameters
        ----------
        node : trace graph node
            The non-prim node to expand
        nodes : list of trace graph node
            All the trace graph nodes within the same scope as the non-prim node
        input_to_node : dict
            key: input name, value: a node that uses this input
        output_to_node : dict
            key: output name, value: a node that generates this output

        Returns
        -------
        GNode
            the expanded non-prim node in GNode format
        """
        # TODO: scope name could be empty
        node_name = '.'.join([self._get_module_name(node.scopeName()), node.kind(), str(self.global_count)])
        _logger.debug("expand non-prim node, node name: %s", node_name)
        self.global_count += 1
        op_type = node.kind()

        node_group = [node]
        inputs = list()
        outputs = list()
        node_queue = queue.Queue()
        node_queue.put(node)
        while not node_queue.empty():
            curr_node = node_queue.get()
            for _input in curr_node.inputs():
                input_name = _input.debugName()
                if input_name in output_to_node and output_to_node[input_name] in nodes:
                        predecessor_node = output_to_node[input_name]
                        if predecessor_node.kind().startswith('prim::'):
                            node_group.append(predecessor_node)
                            node_queue.put(predecessor_node)
                        else:
                            inputs.append(input_name)
                else:
                    inputs.append(input_name)
        for output in node.outputs():
            outputs.append(output.debugName())
        g_node = GNode(node_name, 'func', op_type, inputs, outputs, node_group)
        return g_node

    def _extract_shape_info(self, node):
        """
        Extract the shape information of ```aten::view``` node

        Parameters
        ----------
        node : trace graph node
            It should be ```aten::view``` node

        Returns
        -------
        dict
            Include shape of input tensor and shape of output tensor
        """
        t_input = None
        for _input in node.inputs():
            t_input = _input
            break
        t_output = node.output()
        assert isinstance(t_input.type(), torch._C.TensorType)
        assert isinstance(t_output.type(), torch._C.TensorType)
        in_shape = t_input.type().sizes()
        out_shape = t_output.type().sizes()
        return {'in_shape': in_shape, 'out_shape': out_shape}

    def _extract_leaf_modules(self):
        """
        Extract leaf modules from the given graph. Leaf module means it does not have submodules.
        To extract leaf modules because only leaf module can be replaced. And shape inference can
        be done in leaf module level. Other shape inference is done in lower level i.e.,
        operation level.

        Returns
        -------
        list
            a list of scope name of all the leaf modules
        """
        module_names = sorted([x[0] for x in self.trace.named_modules() if x[0]])
        leaf_nodes = []
        for i, name in enumerate(module_names):
            if (i + 1 >= len(module_names) or not module_names[i + 1].startswith(name)):
                leaf_nodes.append(name)

        return leaf_nodes

    def _extract_module_types(self):
        """
        Extract types (such as 'Conv2d', 'Linear') of model's each sub module and put them in a dict.

        Returns
        -------
        dict
            key: module name
            value: type of the module
        """
        def parse_traced_name(module_name):
            prefix = 'TracedModule['
            suffix = ']'
            if module_name.startswith(prefix) and module_name.endswith(suffix):
                module_name = module_name[len(prefix):-len(suffix)]
            return module_name

        module_to_type = dict()
        for name, module in self.trace.named_modules():
            module_to_type[name] = parse_traced_name(module._name)
        return module_to_type

    def _get_module_name(self, scope_name):
        """
        Retrieve module name from scope name.
        Parameters:
        -----------
        scope_name: str
            scope_name of a graph node, for example:
            for pytorch 1.3.1: MyModel/BackboneModel[backbone]/Conv2d[conv2]
            for pytorch 1.4.0: __module.backbone/__module.backbone.conv2

        Returns:
        -------
        str
            module name, such as backbone.conv2
        """
        if torch.__version__ >= '1.4.0':
            return scope_name.split('/')[-1].replace('__module.', '')
        else:
            return '.'.join(re.findall(r'\[(.*?)\]', scope_name))

    def _build_graph(self):
        """
        Build graph using our defined format from jit trace.
        There are basically three steps: first, construct necessary information (data structures),
        second, extract all the modules to convert to GNode, Third, extract all functions to convert
        to GNode.

        Returns
        -------
        dict
            use name to index g_nodes, key: node name, value: g_node
        dict
            use input (its name) to index g_nodes,
            key: input, value: list of g_nodes that take this input
        dict
            use output (its name) to index g_nodes,
            key: output, value: g_node that generates this output
        """
        graph = self.trace.graph
        _logger.debug(graph)
        # build output mapping, from output debugName to its node
        output_to_node = dict()
        # build input mapping, from input debugName to its node
        input_to_node = dict()
        # build module mapping, from module name to all nodes (as list) under this module scope
        module_to_nodes = dict()
        # the mapping of function (non-module in forward) to nodes, key is scope name
        func_to_nodes = dict()

        graph_inputs = list()
        graph_outputs = list()
        for _input in graph.inputs():
            graph_inputs.append(_input.debugName())
        for output in graph.outputs():
            graph_outputs.append(output.debugName())

        self.leaf_modules = self._extract_leaf_modules()
        module_to_type = self._extract_module_types()
        _logger.debug(self.leaf_modules)

        for node in graph.nodes():
            # populate output_to_node and input_to_node
            for output in node.outputs():
                output_name = output.debugName()
                output_to_node[output_name] = node
            for _input in node.inputs():
                input_name = _input.debugName()
                input_to_node[input_name] = node
            scope_name = node.scopeName()
            module_name = self._get_module_name(scope_name)
            # if module_name is empty, it is not a module
            if not module_name in self.leaf_modules:
                if module_name == '':
                    continue
                else:
                    if module_name in func_to_nodes:
                        func_to_nodes[module_name].append(node)
                    else:
                        func_to_nodes[module_name] = [node]
            else:
                if module_name in module_to_nodes:
                    module_to_nodes[module_name].append(node)
                else:
                    module_to_nodes[module_name] = [node]

        # construct GNode from module
        for module_name, nodes in module_to_nodes.items():
            inputs = set()
            outputs = set()
            for node in nodes:
                for output in node.outputs():
                    outputs.add(output.debugName())
                for _input in node.inputs():
                    inputs.add(_input.debugName())
            m_inputs = list()
            m_outputs = list()
            for output in outputs:
                # TODO: one input could be the input of multiple nodes
                if not output in input_to_node and output in graph_outputs:
                    m_outputs.append(output)
                elif not input_to_node[output] in nodes:
                    m_outputs.append(output)
            for _input in inputs:
                if not _input in output_to_node and _input in graph_inputs:
                    m_inputs.append(_input)
                elif not output_to_node[_input] in nodes:
                    m_inputs.append(_input)
            if module_name == '':
                _logger.warning("module_name is empty string")
            g_node = GNode(module_name, 'module', module_to_type[module_name], m_inputs, m_outputs, nodes)
            self.g_nodes.append(g_node)

        # each scope_name may have multiple funcs, we split them and create GNode for each of them
        for scope_name, nodes in func_to_nodes.items():
            # extract non prim:: nodes
            non_prim_nodes = list()
            for node in nodes:
                if not node.kind().startswith('prim::'):
                    non_prim_nodes.append(node)
            # for each non prim node, expand it has a GNode
            for node in non_prim_nodes:
                g_node = self._expand_non_prim_node(node, nodes, input_to_node, output_to_node)
                self.g_nodes.append(g_node)
                # get shape infor for view (aten::view) func
                if g_node.op_type == 'aten::view':
                    g_node.auxiliary = self._extract_shape_info(node)

        # build index for g_nodes
        name_to_gnode, input_to_gnode, output_to_gnode = self._build_index_for_gnodes(self.g_nodes)

        return name_to_gnode, input_to_gnode, output_to_gnode

    def find_predecessors(self, module_name):
        """
        Find predecessor GNode of the given GNode

        Parameters
        ----------
        module_name : str
            The name of the GNode

        Returns
        -------
        list
            a list of GNodes who are the given GNode's predecessor
        """
        predecessors = []
        for _input in self.name_to_gnode[module_name].inputs:
            if not _input in self.output_to_gnode:
                _logger.debug("cannot find gnode with %s as its output", _input)
            else:
                g_node = self.output_to_gnode[_input]
                predecessors.append(g_node.name)
        return predecessors

    def find_successors(self, module_name):
        """
        Find successor GNodes of the given GNode

        Parameters
        ----------
        module_name : str
            The name of the GNode

        Returns
        -------
        list
            a list of GNodes who are the given GNode's successor
        """
        successors = []
        for output in self.name_to_gnode[module_name].outputs:
            assert output in self.input_to_gnode, "No gnode with input {}".format(output)
            g_nodes = self.input_to_gnode[output]
            for g_node in g_nodes:
                successors.append(g_node.name)
        return successors
